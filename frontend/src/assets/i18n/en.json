{

  "app": {
    "anatomyJwt": "Anatomy of a JWT",
    "bestMethod": "Which is the best method?",
    "documentation": "Documentation",
    "finishTutorial": "Finish tutorial",
    "generatingToken": "Generating a secure token",
    "home": "Home",
    "logout": "Logout = Invalidating tokens",
    "mainPage": "Main Page",
    "reportBug": "Report a bug / improvement",
    "shareTwitter": "Share on Twitter",
    "tokenAuthenticate": "Using token to authenticate",
    "tokenAuthenticate1": "1. Through Request headers",
    "tokenAuthenticate2": "2. Through form body",
    "tokenAuthenticate3": "3. Through request header",
    "tokenAuthenticate4": "4. Through cookies",
    "verifyingToken": "Verifying a token",
    "usedFor": "What is JWT used for?",
    "disclosure": "Disclosures",
    "reference" : "References"
  },

  "anatomy": {
    "anatomyJwt": "What does a JWT look like? (Anatomy of a JWT)",
    "anatomyJwt1": "This is a practical example of a JWT.",
    "anatomyJwt2": "Wow, it looks garbage!",
    "anatomyJwt3": "Sure it does look like garbage, but it is not. In the next few minutes, you'll see how easy it is to turn this garbage into useful information.",
    "decodeHeader": "Click to decode header",
    "decodePayload": "Click to decode payload",
    "decodedHeader": "DECODED HEADER:",
    "decodedPayload": "DECODED PAYLOAD:",
    "edit": "Edit",
    "header": "Header",
    "header1": "This part is the metadata about the cryptography methods used for signature. e.g. The Cryptography Algorithm, Token type, etc.",
    "header2": "What! Where? It is not readable.",
    "header3": "Hold on. The header is encoded with base64UrlEncode, and can easily be decoded by anyone without any additional information other than the token itself. Let's decode this header with browser's <code>atob()</code> method.",
    "payload": "Payload",
    "payload1": "Actual data we want to exchange via this token e.g. userId.",
    "payload2": "This is also encoded with <code>base64UrlEncode</code>. Just like the header, let's decode payload as well with browser's <code>atob()</code> method.",
    "showDecodedHeader": "(This will show you the decoded header in plain text)",
    "showDecodedPayload": "(This will show you the decoded payload in plain text)",
    "signature": "Signature",
    "signature1": "To verify sender or ensure token data integrity.",
    "signature2": "What if this token was tampered somewhere in between when it traveled from the server(where it was created) to your browser(where you're seeing it right now)? You can verify that. <strong>>To verify the token integrity, you'll need to know something more than just the token. You'll need to know a public key</strong> corresponding to the private-key used during the creation of this token.",
    "signature2Tooltip": "In public-key cryptography, a pair of keys is used. A private key is used to create a signature for a message which then can be verified by anyone who has the public key.",
    "signature3": "Luckily, I am the token creator here (for the example token I just showed you). I used a pair of public/private keys for this token and I'm sharing the public key with you, now you go ahead and verify JWT integrity with this public key.",
    "signature4": "The public key (from the public-private key pair I used to secure the token).",
    "takeawayHeader": "Takeaway: The header can be decoded by anyone. It's not garbage for anyone.",
    "takeawayPayload": "Takeaway: The payload can be decoded by anyone. It's not garbage for anyone.",
    "tokenNew": "Generated a new token signed with secret!",
    "tokenSchema": "Token schema",
    "tokenSchema1": "Did you notice two dots(.) in the token? These dots (.) separate 3 important parts of the token.",
    "verifyJwt": "Use this Public Key to Verify JWT"
  },

  "home": {
    "15mins": "15 MINS",
    "jwtToken": "JWT Token Decoder & Encoder: auth-jwt",
    "introduction": "Introduction",
    "introduction1": "This is an interactive tutorial to learn about JWT by reverse engineering.",
    "introduction2": "By the end of this tutorial, you'll learn what a JWT is and how you can implement authentication using JWTs in your app.",
    "introduction3": "We'll start with examples and then reverse engineer by deconstructing each part.",
    "knowledge": "Prior Knowledge Expected",
    "knowledge1": "I am expecting you to have a very high-level overview of following concepts but I  will also make sure to link necessary learning resources wherever you need them.",
    "knowledge2": "HTML forms and cookies",
    "knowledge3": "HTTP web requests",
    "knowledge4": "Public-key cryptography (no need to learn the math, just learn what it does)",
    "knowledge5": "Base64 encoding (no need to learn the math)",
    "learnJwt": "Learn JWT by reverse engineering & debug easily",
    "startInteractive": "Start interactive tutorial",
    "timeRequired": "TIME REQUIRED:"
  },

  "verify": {
    "back": "Back",
    "createMore": "Next: <strong>Create a more complex token</strong>",
    "verified1": "It was verified successfully, what does it mean? It means that the token was exactly the same as when it was created. This verification would have failed, if say a sneaky hacker had intercepted our communication and modified the token before it reached your machine. This is very useful. Isn't it?",
    "verified2": "<strong>Takeaway:</strong> Unlike header and payload, the signature is garbage for everyone, except for someone who got access to the public key from the token creator.",
    "verified3": "Ok, it seems cool but how is this structure useful? How can I use a JWT?",
    "verifiedToken": "VERIFIED AND PAYLOAD DECODED SUCCESSFULLY!",
    "verifyingToken": "Verifying a token"
  },

  "jwtusedfor": {
    "usedFor": "What is JWT used for?",
    "introduction1": "JWTs can be used as a digital claim issued by one party, which another party can verify for integrity.",
    "typicalUse" : "Typical usage of JWTs are",
    "typicalUse1": "To prove whether a user is logged in or not",
    "typicalUse2": "To prove whether a user is authorized to perform admin actions or not",
    "introduction2": "What’s more interesting? In order to verify JWT integrity, the other party(one that verifies) does not need to communicate with the first party(one that created JWT). Well, assuming the first party has shared the public key with the other party already.",
    "leverage": "So what if I leverage this to create a system as following",
    "leverage1": "A computer verifies user identity(e.g. username/password) and issues JWTs to the users. Let’s call it an “identity server”",
    "leverage2": "Another computer that takes requests for users’ protected resources, let’s call it “application server”. It asks for JWT along with the request. This computer(application server) verifies the JWT and makes sure that the JWT was not tampered with",
    "leverage3": "And then the above “application server” uses JWT payload data to decide whether to give access to a particular resource or not. Essentially allowing the access to users as “identity server” wanted (remember the identity server created the JWT in step 1, at that time, it had also put in the access related necessary info in the JWT)",
    "leverage4":"What if we can show a drawing showcasing the JWT issue counter vs JWT verification+access counter. Similar to how token system work at Dominos work.",
    "introduction3": "This is a typical example of authentication/authorization using JWTs and the interesting thing here is that you separated the work related to identity vs work related to actual user resources. You don’t need to rely on a single central system any more to effectively do this and thus can scale and manage in a better way.",
    "system": "Let's see the system in action"
  },

  "generate-token" : {
      "create": "1. Create a JWT",
      "algorithm" : "ALGORITHM:",
      "data": "DATA (PAYLOAD)",
      "data1" : " { 'data' : 'We raised series A' }",
      "note": "Note: Payload needs to be a valid json",
      "note1" : "1. JSON string keys must have double quotes",
      "note2": "2. No functions allowed in value",
      "generateToken": "Generate New Token"
  },

  "generate-token1" : {
    "create": "1. Create a JWT",
    "generate": "generate a new token!",
    "options": "For following options:",
    "operation": "Read about the signing operation",
    "header": "Header : { 'alg':'HS256', 'typ':'JWT' }",
    "payload": "Payload: {'data':'I secretly love Momina Mustehan','iat':1658487904,'exp':1658574304,'aud':'microsoft.com','iss':'Microsoft Inc','sub':'some@user.com'}",
    "secret": "Secret: A secret only server knows",
    "secretKey": "Server can verify this token with secret key (for HMAC algorithm)  or the public key(for RSA algorithm)", 
    "example": "We created this example token to be used to authenticate a user.",
    "backend": " Let’s send this token to a backend server",
    "send": "Next: Send JWT to backend"
  }, 

  "send-jwt1": {
    "introduction": "2. Send JWT to backend with request to access to resources",
    "ways": "There are 4 ways you can send JWT to backend",
    "authenticated": "you have been successfully authenticated",
    "request": "In request parameter",
    "request1": "send jwt token in request parameter",
    "request2": "In this request, we sent token via request URI parameters",
    "queryParameter": "Read about standards to follow while sending token via URI Query Parameter",
    "secureWay": "Let's learn about more secure ways to send the token to the authorization server.",
    "body": "Next: Send token in form body"
  },

  "send-jwt2": {
    "introduction": "2. Send JWT to backend with request to access to resources",
    "ways": "There are 4 ways you can send JWT to backend",
    "authenticated": "you have been successfully authenticated",
    "request": "In form body",
    "request1": "Click to Send Token in form body",
    "request2": "In this request, we sent token via request URI parameters",
    "inputParameter": "Input parameter Name: access_token",
    "contentType": "Content-Type: application/x-www-form-urlencoded",
    "queryParameter": "Read about standards to send token via form-encoded body parameters",
    "secureWay": "There are other ways to send token to authorization server as well",
    "body": "Next: Let's Explore"
  },

  "send-jwt3": {
    "introduction": "2. Send JWT to backend with request to access to resources",
    "ways": "There are 4 ways you can send JWT to backend",
    "authenticated": "you have been successfully authenticated",
    "request": "In request header",
    "request1": "Click to Send Token in form body",
    "request2": "In this request, we sent token via request URI parameters",
    "invalidRequest": "Invalid_request(400-Bad request)",
    "invalidToken": "Invalid_token(401-unauthorized)",
    "scope": "Insufficient_scope(403-Forbidden)",
    "errorCodes": "Error Codes:",
    "queryParameter": "Read about standards to send token via headers",
    "body": "Next: Sending token in cookies",
    "requestHeader": "send token to request header"
  },
  "send-jwt4": {
    "introduction": "2. Send JWT to backend with request to access to resources",
    "ways": "There are 4 ways you can send JWT to backend",
    "authenticated": "you have been successfully authenticated",
    "request": "In request header",
    "request1": "Click to Send Token in form body",
    "request2": "In this request, we sent token via request URI parameters",
    "invalidRequest": "Invalid_request(400-Bad request)",
    "invalidToken": "Invalid_token(401-unauthorized)",
    "scope": "Insufficient_scope(403-Forbidden)",
    "errorCodes": "Error Codes:",
    "queryParameter": "Read about standards to send token via headers",
    "body": "Next: Sending token in cookies",
    "https": "HTTP STATUS : 200"
  }
}
